\documentclass{report}
\title{Project 5}
\author{Bharath Karumudi}
\date{\today}

%%........................................%%
%% Loading the Packages 
%%........................................%%
\usepackage{634format}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{holtex}
\usepackage{holtexbasic}
\usepackage{amssymb}
\input{commands}
\input{../HOL/HOLReports/HOLexType}
\input{../HOL/HOLReports/HOLnexp}
%.........................................%%
%.........................................%%

\begin{document}
 \lstset{language=ML}
 \maketitle{}

 \begin{abstract}
   This project is to demonstrate the capabilities of implementing
   constructing and deconstructing HOL Terms using the tools and
   techniques - \LaTeX{}, AcuTeX, emacs and ML. 

   Each chapter documents the given problems with a structure of:
   \begin{enumerate}
   \item Problem Statement
   \item Relevant Code
   \item Execution Transcripts
   \item Explanation of results
   \end{enumerate}

 \end{abstract}


 \begin{acknowledgments}
  Professor Marvine Hamner and Professor Shiu-Kai Chin who taught the
  Certified Security By Design.
 \end{acknowledgments}

 \tableofcontents{}

 \chapter{Executive Summary}
 \label{cha:executive-summary}

\textbf{All requirements for this project are statisfied specifically,}
 and by using HOL proved the below theorems:
\begin{quote}

\HOLexTypeTheoremsLENGTHXXAPP
\HOLexTypeTheoremsMapXXAPP

\HOLnexpTheoremsAddXXZero
\HOLnexpTheoremsAddXXSYM
\HOLnexpTheoremsSubXXZero
\HOLnexpTheoremsMultXXASSOC


\end{quote}


%%------ Exercise 11.6.1 -------%%

 \chapter{Exercise 11.6.1}
 \label{cha:exercise-11.6.1}
  
 \section{Problem Statement}
 \label{sec:problem-statement-1}

In this exercise we need to prove the theorem:
\HOLTokenTurnstile{} \HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{l\sb{\mathrm{1}}} \HOLBoundVar{l\sb{\mathrm{2}}}. \HOLConst{LENGTH} (\HOLConst{APP} \HOLBoundVar{l\sb{\mathrm{1}}} \HOLBoundVar{l\sb{\mathrm{2}}}) \HOLSymConst{=} \HOLConst{LENGTH} \HOLBoundVar{l\sb{\mathrm{1}}} \HOLSymConst{+} \HOLConst{LENGTH} \HOLBoundVar{l\sb{\mathrm{2}}}

\section{Relevant Code}
\label{sec:relevant-code-1}
 \lstset{frameround=fftt}
\begin{lstlisting}[frame=tRBL]
val LENGTH_APP=
TAC_PROOF(
([],
``!(l1: 'a list)(l2: 'a list).
   (LENGTH (APP l1 l2)) =(LENGTH l1 + LENGTH l2)``),
Induct_on `l1` THEN
ASM_REWRITE_TAC[ADD_CLAUSES,APP_def,LENGTH])

val _ = save_thm("LENGTH_APP", LENGTH_APP);
\end{lstlisting}


\section{Execution Transcripts}
\label{sec:exec-transcr-1}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

---------------------------------------------------------------------
> > # # # Definition has been stored under "APP_def"
val APP_def =
   |- (!(l :'a list). APP ([] :'a list) l = l) /\
   !(h :'a) (l1 :'a list) (l2 :'a list). APP (h::l1) l2 = h::APP l1 l2:
   thm
> # # # # # # # # val LENGTH_APP =
   |- !(l1 :'a list) (l2 :'a list).
     LENGTH (APP l1 l2) = LENGTH l1 + LENGTH l2:
   thm
 
\end{verbatim}
  \end{scriptsize}
\end{session}

\subsection{Explanation of Results}
\label{sec:explanation-results-1}
The above results shows that the requirements are satisfied.

%%------ Exercise 11.6.2 -------%%

 \chapter{Exercise 11.6.2}
 \label{cha:exercise-11.6.2}
  
 \section{Problem Statement}
 \label{sec:problem-statement-2}

In this exercise we need to prove the theorem:
\HOLTokenTurnstile{} \HOLConst{Map} \HOLFreeVar{f} (\HOLConst{APP} \HOLFreeVar{l\sb{\mathrm{1}}} \HOLFreeVar{l\sb{\mathrm{2}}}) \HOLSymConst{=} \HOLConst{APP} (\HOLConst{Map} \HOLFreeVar{f} \HOLFreeVar{l\sb{\mathrm{1}}}) (\HOLConst{Map} \HOLFreeVar{f} \HOLFreeVar{l\sb{\mathrm{2}}})

\section{Relevant Code}
\label{sec:relevant-code-2}
 \lstset{frameround=fftt}
\begin{lstlisting}[frame=tRBL]

val Map_def =
Define
`(Map f [] = []) /\ (Map f (x::f1) = f x::Map f (f1))`;

val Map_APP =
TAC_PROOF(
([],
``Map f (APP l1 l2) = APP (Map f l1) (Map f l2) ``),
Induct_on `l1` THEN
ASM_REWRITE_TAC[ADD_CLAUSES,Map_def,APP_def])

val _ = save_thm("Map_APP", Map_APP);

\end{lstlisting}


\section{Execution Transcripts}
\label{sec:exec-transcr-2}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

---------------------------------------------------------------------
> > # # # # # # # <<HOL message: inventing new type variable names: 'a, 'b>>
val Map_APP =
   |- Map (f :'b -> 'a) (APP (l1 :'b list) (l2 :'b list)) =
   APP (Map f l1) (Map f l2):
   thm

\end{verbatim}
  \end{scriptsize}
\end{session}

\subsection{Explanation of Results}
\label{sec:explanation-results-2}
The above results shows that the requirements are satisfied.


%%------ Exercise 11.6.3 -------%%

 \chapter{Exercise 11.6.3}
 \label{cha:exercise-11.6.3}
  
 \section{Problem Statement}
 \label{sec:problem-statement-3}

In this exercise we need to prove the following:  

\HOLnexpTheoremsAddXXZero
\HOLnexpTheoremsAddXXSYM
\HOLnexpTheoremsSubXXZero
\HOLnexpTheoremsMultXXASSOC

\section{Relevant Code}
\label{sec:relevant-code-3}
 \lstset{frameround=fftt}
\begin{lstlisting}[frame=tRBL]

val _ = Datatype
`nexp = Num num | Add nexp nexp | Sub nexp nexp | Mult nexp nexp`;

val Add_0 =
TAC_PROOF(([],``!(f:nexp).nexpVal(Add (Num 0) f) = nexpVal (f)``),
Induct_on `f` THEN
ASM_REWRITE_TAC[nexpVal_def] THEN
ASM_REWRITE_TAC[ADD_CLAUSES]);

val _ = save_thm("Add_0",Add_0)

val Add_SYM =
TAC_PROOF(([],``!f1 f2.nexpVal (Add f1 f2) = nexpVal (Add f2 f1)``),
Induct_on`f1` THEN
PROVE_TAC [nexpVal_def, ADD_SYM]);

val _ = save_thm("Add_SYM",Add_SYM)

val Sub_0 =
TAC_PROOF(([],
``!f.(nexpVal (Sub (Num 0) f ) = 0) âˆ§
  (nexpVal (Sub f (Num 0)) = nexpVal f )``),
STRIP_TAC THEN
ASM_REWRITE_TAC[nexpVal_def] THEN
PROVE_TAC[nexpVal_def, SUB_0]);

val _ = save_thm("Sub_0",Sub_0)


val Mult_ASSOC =
TAC_PROOF(([],``!f1 f2 f3.
   nexpVal (Mult f1 (Mult f2 f3)) =
   nexpVal (Mult (Mult f1 f2) f3)``),
REPEAT STRIP_TAC THEN
PROVE_TAC[nexpVal_def, MULT_ASSOC]);

val _ = save_thm("Mult_ASSOC",Mult_ASSOC)

\end{lstlisting}


\section{Execution Transcripts}
\label{sec:exec-transcr-3}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

---------------------------------------------------------------------
> # <<HOL message: Defined type: "nexp">>
> # val nexp_one_one =
   |- (!(a :num) (a' :num). (Num a = Num a') <=> (a = a')) /\
   (!(a0 :nexp) (a1 :nexp) (a0' :nexp) (a1' :nexp).
      (Add a0 a1 = Add a0' a1') <=> (a0 = a0') /\ (a1 = a1')) /\
   (!(a0 :nexp) (a1 :nexp) (a0' :nexp) (a1' :nexp).
      (Sub a0 a1 = Sub a0' a1') <=> (a0 = a0') /\ (a1 = a1')) /\
   !(a0 :nexp) (a1 :nexp) (a0' :nexp) (a1' :nexp).
     (Mult a0 a1 = Mult a0' a1') <=> (a0 = a0') /\ (a1 = a1'):
   thm
> # val nexp_distinct_clauses =
   |- (!(a1 :nexp) (a0 :nexp) (a :num). Num a <> Add a0 a1) /\
   (!(a1 :nexp) (a0 :nexp) (a :num). Num a <> Sub a0 a1) /\
   (!(a1 :nexp) (a0 :nexp) (a :num). Num a <> Mult a0 a1) /\
   (!(a1' :nexp) (a1 :nexp) (a0' :nexp) (a0 :nexp).
      Add a0 a1 <> Sub a0' a1') /\
   (!(a1' :nexp) (a1 :nexp) (a0' :nexp) (a0 :nexp).
      Add a0 a1 <> Mult a0' a1') /\
   !(a1' :nexp) (a1 :nexp) (a0' :nexp) (a0 :nexp).
     Sub a0 a1 <> Mult a0' a1':
   thm
> # # # # # # Definition has been stored under "nexpVal_def"
val nexpVal_def =
   |- (!(f :num). nexpVal (Num f) = f) /\
   (!(f1 :nexp) (f2 :nexp).
      nexpVal (Add f1 f2) = nexpVal f1 + nexpVal f2) /\
   (!(f1 :nexp) (f2 :nexp).
      nexpVal (Sub f1 f2) = nexpVal f1 - nexpVal f2) /\
   !(f1 :nexp) (f2 :nexp).
     nexpVal (Mult f1 f2) = nexpVal f1 * nexpVal f2:
   thm
> # # # # val Add_0 =
   |- !(f :nexp). nexpVal (Add (Num (0 :num)) f) = nexpVal f:
   thm
> > # > # # # Meson search level: ..........
Meson search level: ..........
Meson search level: ..........
Meson search level: ..........
val Add_SYM =
   |- !(f1 :nexp) (f2 :nexp). nexpVal (Add f1 f2) = nexpVal (Add f2 f1):
   thm
> > > # # # # # # Meson search level: ....
val Sub_0 =
   |- !(f :nexp).
     (nexpVal (Sub (Num (0 :num)) f) = (0 :num)) /\
     (nexpVal (Sub f (Num (0 :num))) = nexpVal f):
   thm
> > > # # # # # Meson search level: ......................
val Mult_ASSOC =
   |- !(f1 :nexp) (f2 :nexp) (f3 :nexp).
     nexpVal (Mult f1 (Mult f2 f3)) = nexpVal (Mult (Mult f1 f2) f3):
   thm
> > > 

\end{verbatim}
  \end{scriptsize}
\end{session}

\subsection{Explanation of Results}
\label{sec:explanation-results-3}
The above results shows that the requirements are satisfied.


\chapter{Appendix A: Exercise 11.6.1 and 11.6.2}
\label{cha:appendix-a:chapter9}

The following code is from the file exTypeScript.sml
\lstinputlisting{../HOL/exTypeScript.sml}

\chapter{Appendix B: Exercise 11.6.3}
\label{cha:appendix-a:chapter10}

The following code is from the file nexpScript.sml
\lstinputlisting{../HOL/nexpScript.sml}

\end{document}