/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:88: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:125: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:162: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:250: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f1_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1245: warning: Matches are not exhaustive. Found near fn [th1, th2] => ACL_CONJ th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1276: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ1 disj2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1304: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ2 disj1 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1336: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1337: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1340: warning: Matches are not exhaustive. Found near fn [th] => ACL_MP th2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1374: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1408: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1440: warning: Matches are not exhaustive. Found near fn [th1, th2] => CONTROLS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1473: warning: Matches are not exhaustive. Found near fn [th1, th2] => DC th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1506: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMI_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1541: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMS_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1575: warning: Matches are not exhaustive. Found near fn [th1, th2] => HS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1601: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1602: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1604: warning: Pattern is not exhaustive.
Found near val (_, [proptype, ...]) = dest_type formType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1643: warning: Matches are not exhaustive.
Found near fn [th1, th2, th3] => IL_DOMI th2 th1 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1679: warning: Matches are not exhaustive.
Found near fn [th1, th2] => MONO_SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1709: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1710: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1745: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1776: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1810: warning: Matches are not exhaustive. Found near fn [th1, th2, th3] => REPS th1 th2 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1842: warning: Matches are not exhaustive. Found near fn [th1, th2] => REP_SAYS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1869: warning: Matches are not exhaustive. Found near fn [th] => SAYS princ th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1901: warning: Matches are not exhaustive. Found near fn [th1, th2] => SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1934: warning: Matches are not exhaustive.
Found near fn [th1, th2] => TRANS_SPEAKS_FOR th1 th2
<<HOL message: Created theory "question2">>
Saved theorem _____ "num2commands_commands2num"
Saved theorem _____ "commands2num_num2commands"
Saved theorem _____ "num2commands_11"
Saved theorem _____ "commands2num_11"
Saved theorem _____ "num2commands_ONTO"
Saved theorem _____ "commands2num_ONTO"
Saved theorem _____ "num2commands_thm"
Saved theorem _____ "commands2num_thm"
Saved theorem _____ "commands_EQ_commands"
Saved theorem _____ "commands_case_def"
Saved theorem _____ "datatype_commands"
Saved theorem _____ "commands_distinct"
Saved theorem _____ "commands_case_cong"
Saved theorem _____ "commands_nchotomy"
Saved theorem _____ "commands_Axiom"
Saved theorem _____ "commands_induction"
<<HOL message: Defined type: "commands">>
Saved theorem _____ "num2people_people2num"
Saved theorem _____ "people2num_num2people"
Saved theorem _____ "num2people_11"
Saved theorem _____ "people2num_11"
Saved theorem _____ "num2people_ONTO"
Saved theorem _____ "people2num_ONTO"
Saved theorem _____ "num2people_thm"
Saved theorem _____ "people2num_thm"
Saved theorem _____ "people_EQ_people"
Saved theorem _____ "people_case_def"
Saved theorem _____ "datatype_people"
Saved theorem _____ "people_distinct"
Saved theorem _____ "people_case_cong"
Saved theorem _____ "people_nchotomy"
Saved theorem _____ "people_Axiom"
Saved theorem _____ "people_induction"
<<HOL message: Defined type: "people">>
Saved theorem _____ "num2roles_roles2num"
Saved theorem _____ "roles2num_num2roles"
Saved theorem _____ "num2roles_11"
Saved theorem _____ "roles2num_11"
Saved theorem _____ "num2roles_ONTO"
Saved theorem _____ "roles2num_ONTO"
Saved theorem _____ "num2roles_thm"
Saved theorem _____ "roles2num_thm"
Saved theorem _____ "roles_EQ_roles"
Saved theorem _____ "roles_case_def"
Saved theorem _____ "datatype_roles"
Saved theorem _____ "roles_distinct"
Saved theorem _____ "roles_case_cong"
Saved theorem _____ "roles_nchotomy"
Saved theorem _____ "roles_Axiom"
Saved theorem _____ "roles_induction"
<<HOL message: Defined type: "roles">>
Saved theorem _____ "datatype_keyPrinc"
Saved theorem _____ "keyPrinc_11"
Saved theorem _____ "keyPrinc_distinct"
Saved theorem _____ "keyPrinc_case_cong"
Saved theorem _____ "keyPrinc_nchotomy"
Saved theorem _____ "keyPrinc_Axiom"
Saved theorem _____ "keyPrinc_induction"
<<HOL message: Defined type: "keyPrinc">>
Saved theorem _____ "datatype_principals"
Saved theorem _____ "principals_11"
Saved theorem _____ "principals_distinct"
Saved theorem _____ "principals_case_cong"
Saved theorem _____ "principals_nchotomy"
Saved theorem _____ "principals_Axiom"
Saved theorem _____ "principals_induction"
<<HOL message: Defined type: "principals">>
Saved theorem _____ "question2Thm"
Theory: question2

Parents:
    aclDrules

Type constants:
    commands 0
    keyPrinc 0
    people 0
    principals 0
    roles 0

Term constants:
    Alice             :people
    Ap                :num -> keyPrinc
    Bob               :people
    Key               :keyPrinc -> principals
    PR                :keyPrinc -> principals
    Role              :roles -> keyPrinc
    Staff             :people -> keyPrinc
    commands2num      :commands -> num
    commands_CASE     :commands -> α -> α -> α
    commands_size     :commands -> num
    debit             :commands
    keyPrinc_CASE     :keyPrinc ->
                       (people -> α) -> (roles -> α) -> (num -> α) -> α
    keyPrinc_size     :keyPrinc -> num
    num2commands      :num -> commands
    num2people        :num -> people
    num2roles         :num -> roles
    pay               :commands
    payee             :roles
    payer             :roles
    people2num        :people -> num
    people_CASE       :people -> α -> α -> α
    people_size       :people -> num
    principals_CASE   :principals ->
                       (keyPrinc -> α) -> (keyPrinc -> α) -> α
    principals_size   :principals -> num
    roles2num         :roles -> num
    roles_CASE        :roles -> α -> α -> α
    roles_size        :roles -> num

Definitions:
    @tempAlice_def
      |- Alice = num2people 0
    @tempBob_def
      |- Bob = num2people 1
    @tempdebit_def
      |- debit = num2commands 1
    @temppay_def
      |- pay = num2commands 0
    @temppayee_def
      |- payee = num2roles 1
    @temppayer_def
      |- payer = num2roles 0
    commands_BIJ
      |- (∀a. num2commands (commands2num a) = a) ∧
         ∀r. (λn. n < 2) r ⇔ (commands2num (num2commands r) = r)
    commands_CASE
      |- ∀x v0 v1.
           (case x of pay => v0 | debit => v1) =
           (λm. if m = 0 then v0 else v1) (commands2num x)
    commands_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep
    commands_size_def
      |- ∀x. commands_size x = 0
    keyPrinc_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'keyPrinc' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR 0 (a,ARB,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC 0) (ARB,a,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC (SUC 0)) (ARB,ARB,a)
                             (λn. ind_type$BOTTOM)) a) ⇒
                     'keyPrinc' a0) ⇒
                  'keyPrinc' a0) rep
    keyPrinc_case_def
      |- (∀a f f1 f2. keyPrinc_CASE (Staff a) f f1 f2 = f a) ∧
         (∀a f f1 f2. keyPrinc_CASE (Role a) f f1 f2 = f1 a) ∧
         ∀a f f1 f2. keyPrinc_CASE (Ap a) f f1 f2 = f2 a
    keyPrinc_size_def
      |- (∀a. keyPrinc_size (Staff a) = 1 + people_size a) ∧
         (∀a. keyPrinc_size (Role a) = 1 + roles_size a) ∧
         ∀a. keyPrinc_size (Ap a) = 1 + a
    people_BIJ
      |- (∀a. num2people (people2num a) = a) ∧
         ∀r. (λn. n < 2) r ⇔ (people2num (num2people r) = r)
    people_CASE
      |- ∀x v0 v1.
           (case x of Alice => v0 | Bob => v1) =
           (λm. if m = 0 then v0 else v1) (people2num x)
    people_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep
    people_size_def
      |- ∀x. people_size x = 0
    principals_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'principals' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC 0) a
                             (λn. ind_type$BOTTOM)) a) ⇒
                     'principals' a0) ⇒
                  'principals' a0) rep
    principals_case_def
      |- (∀a f f1. principals_CASE (PR a) f f1 = f a) ∧
         ∀a f f1. principals_CASE (Key a) f f1 = f1 a
    principals_size_def
      |- (∀a. principals_size (PR a) = 1 + keyPrinc_size a) ∧
         ∀a. principals_size (Key a) = 1 + keyPrinc_size a
    roles_BIJ
      |- (∀a. num2roles (roles2num a) = a) ∧
         ∀r. (λn. n < 2) r ⇔ (roles2num (num2roles r) = r)
    roles_CASE
      |- ∀x v0 v1.
           (case x of payer => v0 | payee => v1) =
           (λm. if m = 0 then v0 else v1) (roles2num x)
    roles_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep
    roles_size_def
      |- ∀x. roles_size x = 0

Theorems:
    commands2num_11
      |- ∀a a'. (commands2num a = commands2num a') ⇔ (a = a')
    commands2num_ONTO
      |- ∀r. r < 2 ⇔ ∃a. r = commands2num a
    commands2num_num2commands
      |- ∀r. r < 2 ⇔ (commands2num (num2commands r) = r)
    commands2num_thm
      |- (commands2num pay = 0) ∧ (commands2num debit = 1)
    commands_Axiom
      |- ∀x0 x1. ∃f. (f pay = x0) ∧ (f debit = x1)
    commands_EQ_commands
      |- ∀a a'. (a = a') ⇔ (commands2num a = commands2num a')
    commands_case_cong
      |- ∀M M' v0 v1.
           (M = M') ∧ ((M' = pay) ⇒ (v0 = v0')) ∧
           ((M' = debit) ⇒ (v1 = v1')) ⇒
           ((case M of pay => v0 | debit => v1) =
            case M' of pay => v0' | debit => v1')
    commands_case_def
      |- (∀v0 v1. (case pay of pay => v0 | debit => v1) = v0) ∧
         ∀v0 v1. (case debit of pay => v0 | debit => v1) = v1
    commands_distinct
      |- pay ≠ debit
    commands_induction
      |- ∀P. P debit ∧ P pay ⇒ ∀a. P a
    commands_nchotomy
      |- ∀a. (a = pay) ∨ (a = debit)
    datatype_commands
      |- DATATYPE (commands pay debit)
    datatype_keyPrinc
      |- DATATYPE (keyPrinc Staff Role Ap)
    datatype_people
      |- DATATYPE (people Alice Bob)
    datatype_principals
      |- DATATYPE (principals PR Key)
    datatype_roles
      |- DATATYPE (roles payer payee)
    keyPrinc_11
      |- (∀a a'. (Staff a = Staff a') ⇔ (a = a')) ∧
         (∀a a'. (Role a = Role a') ⇔ (a = a')) ∧
         ∀a a'. (Ap a = Ap a') ⇔ (a = a')
    keyPrinc_Axiom
      |- ∀f0 f1 f2.
           ∃fn.
             (∀a. fn (Staff a) = f0 a) ∧ (∀a. fn (Role a) = f1 a) ∧
             ∀a. fn (Ap a) = f2 a
    keyPrinc_case_cong
      |- ∀M M' f f1 f2.
           (M = M') ∧ (∀a. (M' = Staff a) ⇒ (f a = f' a)) ∧
           (∀a. (M' = Role a) ⇒ (f1 a = f1' a)) ∧
           (∀a. (M' = Ap a) ⇒ (f2 a = f2' a)) ⇒
           (keyPrinc_CASE M f f1 f2 = keyPrinc_CASE M' f' f1' f2')
    keyPrinc_distinct
      |- (∀a' a. Staff a ≠ Role a') ∧ (∀a' a. Staff a ≠ Ap a') ∧
         ∀a' a. Role a ≠ Ap a'
    keyPrinc_induction
      |- ∀P.
           (∀p. P (Staff p)) ∧ (∀r. P (Role r)) ∧ (∀n. P (Ap n)) ⇒
           ∀k. P k
    keyPrinc_nchotomy
      |- ∀kk. (∃p. kk = Staff p) ∨ (∃r. kk = Role r) ∨ ∃n. kk = Ap n
    num2commands_11
      |- ∀r r'.
           r < 2 ⇒
           r' < 2 ⇒
           ((num2commands r = num2commands r') ⇔ (r = r'))
    num2commands_ONTO
      |- ∀a. ∃r. (a = num2commands r) ∧ r < 2
    num2commands_commands2num
      |- ∀a. num2commands (commands2num a) = a
    num2commands_thm
      |- (num2commands 0 = pay) ∧ (num2commands 1 = debit)
    num2people_11
      |- ∀r r'.
           r < 2 ⇒ r' < 2 ⇒ ((num2people r = num2people r') ⇔ (r = r'))
    num2people_ONTO
      |- ∀a. ∃r. (a = num2people r) ∧ r < 2
    num2people_people2num
      |- ∀a. num2people (people2num a) = a
    num2people_thm
      |- (num2people 0 = Alice) ∧ (num2people 1 = Bob)
    num2roles_11
      |- ∀r r'.
           r < 2 ⇒ r' < 2 ⇒ ((num2roles r = num2roles r') ⇔ (r = r'))
    num2roles_ONTO
      |- ∀a. ∃r. (a = num2roles r) ∧ r < 2
    num2roles_roles2num
      |- ∀a. num2roles (roles2num a) = a
    num2roles_thm
      |- (num2roles 0 = payer) ∧ (num2roles 1 = payee)
    people2num_11
      |- ∀a a'. (people2num a = people2num a') ⇔ (a = a')
    people2num_ONTO
      |- ∀r. r < 2 ⇔ ∃a. r = people2num a
    people2num_num2people
      |- ∀r. r < 2 ⇔ (people2num (num2people r) = r)
    people2num_thm
      |- (people2num Alice = 0) ∧ (people2num Bob = 1)
    people_Axiom
      |- ∀x0 x1. ∃f. (f Alice = x0) ∧ (f Bob = x1)
    people_EQ_people
      |- ∀a a'. (a = a') ⇔ (people2num a = people2num a')
    people_case_cong
      |- ∀M M' v0 v1.
           (M = M') ∧ ((M' = Alice) ⇒ (v0 = v0')) ∧
           ((M' = Bob) ⇒ (v1 = v1')) ⇒
           ((case M of Alice => v0 | Bob => v1) =
            case M' of Alice => v0' | Bob => v1')
    people_case_def
      |- (∀v0 v1. (case Alice of Alice => v0 | Bob => v1) = v0) ∧
         ∀v0 v1. (case Bob of Alice => v0 | Bob => v1) = v1
    people_distinct
      |- Alice ≠ Bob
    people_induction
      |- ∀P. P Alice ∧ P Bob ⇒ ∀a. P a
    people_nchotomy
      |- ∀a. (a = Alice) ∨ (a = Bob)
    principals_11
      |- (∀a a'. (PR a = PR a') ⇔ (a = a')) ∧
         ∀a a'. (Key a = Key a') ⇔ (a = a')
    principals_Axiom
      |- ∀f0 f1. ∃fn. (∀a. fn (PR a) = f0 a) ∧ ∀a. fn (Key a) = f1 a
    principals_case_cong
      |- ∀M M' f f1.
           (M = M') ∧ (∀a. (M' = PR a) ⇒ (f a = f' a)) ∧
           (∀a. (M' = Key a) ⇒ (f1 a = f1' a)) ⇒
           (principals_CASE M f f1 = principals_CASE M' f' f1')
    principals_distinct
      |- ∀a' a. PR a ≠ Key a'
    principals_induction
      |- ∀P. (∀k. P (PR k)) ∧ (∀k. P (Key k)) ⇒ ∀p. P p
    principals_nchotomy
      |- ∀pp. (∃k. pp = PR k) ∨ ∃k. pp = Key k
    question2Thm
      |- (M,Oi,Os) sat Name (PR (Role payer)) controls prop pay ⇒
         (M,Oi,Os) sat
         reps (Name (PR (Staff Alice))) (Name (PR (Role payer)))
           (prop pay) ⇒
         (M,Oi,Os) sat
         Name (Key (Staff Alice)) quoting Name (PR (Role payer)) says
         prop pay ⇒
         (M,Oi,Os) sat prop pay impf prop debit ⇒
         (M,Oi,Os) sat
         Name (Key (Role payee)) speaks_for Name (PR (Role payee)) ⇒
         (M,Oi,Os) sat
         Name (Key (Role payee)) says
         Name (Key (Staff Alice)) speaks_for Name (PR (Staff Alice)) ⇒
         (M,Oi,Os) sat
         Name (PR (Role payee)) controls
         Name (Key (Staff Alice)) speaks_for Name (PR (Staff Alice)) ⇒
         (M,Oi,Os) sat
         Name (Key (Staff Bob)) quoting Name (PR (Role Operator)) says
         prop debit
    roles2num_11
      |- ∀a a'. (roles2num a = roles2num a') ⇔ (a = a')
    roles2num_ONTO
      |- ∀r. r < 2 ⇔ ∃a. r = roles2num a
    roles2num_num2roles
      |- ∀r. r < 2 ⇔ (roles2num (num2roles r) = r)
    roles2num_thm
      |- (roles2num payer = 0) ∧ (roles2num payee = 1)
    roles_Axiom
      |- ∀x0 x1. ∃f. (f payer = x0) ∧ (f payee = x1)
    roles_EQ_roles
      |- ∀a a'. (a = a') ⇔ (roles2num a = roles2num a')
    roles_case_cong
      |- ∀M M' v0 v1.
           (M = M') ∧ ((M' = payer) ⇒ (v0 = v0')) ∧
           ((M' = payee) ⇒ (v1 = v1')) ⇒
           ((case M of payer => v0 | payee => v1) =
            case M' of payer => v0' | payee => v1')
    roles_case_def
      |- (∀v0 v1. (case payer of payer => v0 | payee => v1) = v0) ∧
         ∀v0 v1. (case payee of payer => v0 | payee => v1) = v1
    roles_distinct
      |- payer ≠ payee
    roles_induction
      |- ∀P. P payee ∧ P payer ⇒ ∀a. P a
    roles_nchotomy
      |- ∀a. (a = payer) ∨ (a = payee)
Exporting theory "question2" ... done.
Theory "question2" took 0.22933s to build
Completed load of question2Script
